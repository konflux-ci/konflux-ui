import { FlagKey } from '../flags';
import { parseUrlForFeatureFlags, FeatureFlagsStore } from '../store';

describe('parseUrl()', () => {
  it('returns an empty object when no feature-flag params are present', () => {
    expect(parseUrlForFeatureFlags('')).toEqual({});
    expect(parseUrlForFeatureFlags('?q=search')).toEqual({});
  });

  it('parses the bulk "ff" param as “true” for every flag listed', () => {
    const result = parseUrlForFeatureFlags('?ff=alpha,beta,gamma');
    expect(result).toEqual({ alpha: true, beta: true, gamma: true });
  });

  it('parses individual "ff_<flag>" params and respects explicit true/false', () => {
    const result = parseUrlForFeatureFlags('?ff_foo=true&ff_bar=false&ff_baz=0');
    expect(result).toEqual({ foo: true, bar: false, baz: true });
  });

  it('merges bulk and keyed flags; keyed flags override duplicates set by bulk', () => {
    const result = parseUrlForFeatureFlags('?ff=alpha,beta&ff_beta=false&ff_gamma=true');
    expect(result).toEqual({ alpha: true, beta: false, gamma: true });
  });

  it('accepts a leading "?" or not', () => {
    const a = parseUrlForFeatureFlags('?ff=one');
    const b = parseUrlForFeatureFlags('ff=one');
    expect(a).toEqual(b);
  });

  it('treats a valueless keyed flag as true', () => {
    const result = parseUrlForFeatureFlags('?ff_newflag');
    expect(result).toEqual({ newflag: true });
  });
});

jest.mock('../flags', () => ({
  FLAGS: {
    featureA: { defaultEnabled: false },
    featureB: { defaultEnabled: true },
  },
}));

describe('FeatureFlagsStore', () => {
  beforeEach(() => {
    localStorage.clear();
    history.replaceState(null, '', '/');
    FeatureFlagsStore.refresh();
  });

  it('should initialize state with default values from FLAGS', () => {
    expect(FeatureFlagsStore.state).toEqual({
      featureA: false,
      featureB: true,
    });
  });

  it('should override state with URL search params', () => {
    history.replaceState(null, '', '/?ff=featureA&ff_featureB=false');
    FeatureFlagsStore.refresh();

    expect(FeatureFlagsStore.state).toEqual({
      featureA: true,
      featureB: false,
    });
  });

  it('should override state with localStorage values', () => {
    localStorage.setItem('__ff_overrides__', JSON.stringify({ featureA: true }));
    FeatureFlagsStore.refresh();

    expect(FeatureFlagsStore.state).toEqual({
      featureA: true,
      featureB: true,
    });
  });

  it('should update state and persist changes to localStorage and URL', () => {
    FeatureFlagsStore.set('featureA' as FlagKey, true);

    expect(FeatureFlagsStore.state['featureA' as FlagKey]).toBe(true);
    expect(localStorage.getItem('__ff_overrides__')).toContain('"featureA":true');
    expect(location.search).toContain('ff_featureA=true');
  });

  it('should reset all feature flags', () => {
    FeatureFlagsStore.set('featureA' as FlagKey, true);
    FeatureFlagsStore.resetAll();

    expect(FeatureFlagsStore.state).toEqual({
      featureA: false,
      featureB: true,
    });
    expect(localStorage.getItem('__ff_overrides__')).toBeNull();
    expect(location.search).toBe('');
  });

  it('should notify subscribers on state change', () => {
    const callback = jest.fn();
    const unsubscribe = FeatureFlagsStore.subscribe(callback);

    FeatureFlagsStore.set('featureA' as FlagKey, true);
    expect(callback).toHaveBeenCalledTimes(1);

    FeatureFlagsStore.set('featureA' as FlagKey, false);
    expect(callback).toHaveBeenCalledTimes(2);

    unsubscribe();
    FeatureFlagsStore.set('featureA' as FlagKey, true);
    expect(callback).toHaveBeenCalledTimes(2);
  });

  it('should not update state if the value is unchanged', () => {
    const callback = jest.fn();
    FeatureFlagsStore.subscribe(callback);

    FeatureFlagsStore.set('featureA' as FlagKey, false);
    expect(callback).not.toHaveBeenCalled();
  });

  it('should handle invalid localStorage data gracefully', () => {
    localStorage.setItem('__ff_overrides__', 'invalid-json');
    expect(() => FeatureFlagsStore.refresh()).not.toThrow();
    expect(FeatureFlagsStore.state).toEqual({
      featureA: false,
      featureB: true,
    });
  });

  it('should update URL search params correctly when toggling flags', () => {
    FeatureFlagsStore.set('featureA' as FlagKey, true);
    expect(location.search).toContain('ff_featureA=true');

    FeatureFlagsStore.set('featureA' as FlagKey, false);
    expect(location.search).toContain('ff_featureA=false');
  });

  it('should remove URL search params when resetting all flags', () => {
    FeatureFlagsStore.set('featureA' as FlagKey, true);
    expect(location.search).toContain('ff_featureA=true');

    FeatureFlagsStore.resetAll();

    expect(location.search).toBe('');
  });
});

/**
 * Additional unit tests generated by CodeRabbit Inc
 * Testing library/framework: Jest with TypeScript (ts-jest)
 * Scope: Focused on parseUrlForFeatureFlags and FeatureFlagsStore behaviors highlighted in the PR diff.
 */

describe('parseUrl() — additional cases', () => {
  it('returns an empty object when the bulk "ff" param is present but empty', () => {
    expect(parseUrlForFeatureFlags('?ff=')).toEqual({});
    expect(parseUrlForFeatureFlags('?q=x&ff=&other=y')).toEqual({});
    expect(parseUrlForFeatureFlags('?ff=,&ff_alpha=true')).toEqual({ alpha: true });
  });

  it('trims whitespace, ignores empty tokens, and deduplicates items in the bulk list', () => {
    const result = parseUrlForFeatureFlags('?ff=alpha, alpha , ,beta, ');
    expect(result.alpha).toBe(true);
    expect(result.beta).toBe(true);
    // Ensure we did not accidentally record keys containing whitespace
    expect(Object.keys(result).every((k) => k.trim() === k)).toBe(true);
  });

  it('ignores unrelated query params that do not match ff or ff_<key> patterns', () => {
    const result = parseUrlForFeatureFlags('?fff_alpha=true&ffnot_beta=true&foo=bar');
    expect(result).toEqual({});
  });
});

describe('FeatureFlagsStore — additional cases', () => {
  beforeEach(() => {
    localStorage.clear();
    history.replaceState(null, '', '/');
    FeatureFlagsStore.refresh();
  });

  it('ignores unknown flags supplied via URL overrides', () => {
    history.replaceState(null, '', '/?ff=featureC&ff_featureC=true');
    FeatureFlagsStore.refresh();

    expect(FeatureFlagsStore.state).toEqual({
      featureA: false,
      featureB: true,
    });
  });

  it('ignores unknown flags supplied via localStorage overrides', () => {
    localStorage.setItem('__ff_overrides__', JSON.stringify({ featureC: true }));
    FeatureFlagsStore.refresh();

    expect(FeatureFlagsStore.state).toEqual({
      featureA: false,
      featureB: true,
    });
  });

  it('persists non-default override to localStorage and updates URL for featureB', () => {
    // defaultEnabled for featureB is true (see jest.mock above); set to false should persist
    FeatureFlagsStore.set('featureB' as FlagKey, false);

    const overrides = JSON.parse(localStorage.getItem('__ff_overrides__') || '{}');
    expect(overrides).toMatchObject({ featureB: false });
    expect(location.search).toContain('ff_featureB=false');
  });

  it('does not write to localStorage when setting a flag to its current value', () => {
    const before = localStorage.getItem('__ff_overrides__'); // null or previous value
    FeatureFlagsStore.set('featureA' as FlagKey, false); // featureA default is false; no-op
    expect(localStorage.getItem('__ff_overrides__')).toBe(before);
  });

  it('unsubscribe can be called multiple times without throwing', () => {
    const unsubscribe = FeatureFlagsStore.subscribe(() => {});
    expect(() => unsubscribe()).not.toThrow();
    expect(() => unsubscribe()).not.toThrow();
  });

  it('state only contains known flag keys from FLAGS', () => {
    expect(Object.keys(FeatureFlagsStore.state).sort()).toEqual(['featureA', 'featureB']);
  });
});
